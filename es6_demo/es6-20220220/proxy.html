<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // Proxy 实例的方法
    // 1、get() 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。

    // var persion = {
    //   name: 'tom'
    // }
    // var proxy = new Proxy(persion, {
    //   get: function(target, propKey, receiver) {
    //     // console.log('target, propKey, receiver: ', target, propKey, receiver);
    //     if(propKey in target) {
    //       return target[propKey]
    //     } else {
    //       throw new ReferenceError("prop name \""+propKey + "\" does not exist.")
    //     }
    //   }
    // })
    // console.log(proxy.name); // tom
    // // console.log(proxy.jack); // ReferenceError:

    // 同一个拦截器函数，可以设置拦截多个操作。
    // function sum(x, y) {
    //   return x + y
    // }
    // var handler = {
    //   get: function (target, key, receiver) {
    //     console.log(receiver === fproxy, ); // true
    //     console.log('key: ', key);
    //     if (key === 'prototype') {
    //       return Object.prototype
    //     }
    //     // return 'hello, ' + key
    //     return Reflect.get(target, key)
    //     // return target[key]
    //   },
    //   apply: function (target, thisBinding, args) {
    //     // console.log(arguments, '=======apply');
    //     return args[0]
    //   },
    //   construct: function (target, args) {
    //     // console.log(arguments, '=======construct');
    //     return { value: args[1] }
    //   }

    // }
    // var fproxy = new Proxy(sum, handler)
    // // console.log('fproxy: ', fproxy.a);

    // // console.log(typeof fproxy, '=====fproxy'); // function
    // // console.log('fproxy(1,3): ', fproxy(1,3)); // 1
    // // console.log(fproxy.apply({name: 'jack'}, [3,2])); // 3
    // console.log(fproxy.call({name: 'jack'}, ...[5,2])); // 5

    // // console.log(new fproxy(1,2)); // {"value": 2 } 返回不是对象会报错
    // // console.log(fproxy.prototype === Object.prototype); // true


    // 1.get方法
    // 1.1使用get拦截，实现数组读取负数的索引。
    // function createArray(...args) {
    //   const handler = {
    //     get(target, key, receiver) {
    //       if(key < 0) {
    //         // console.log(target, key);
    //         key = +key
    //         return Reflect.get(target, target.length+key, receiver)
    //       }
    //       return Reflect.get(target, key, receiver)
    //     }
    //   }
    //   const arr = []
    //   arr.push(...args)
    //   return new Proxy(arr, handler)
    // }

    // const arr = createArray(2,3,4,5)
    // console.log(arr[2]);// 4
    // console.log(arr[-1]);// 5

    // 1.2.利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。
    // var double = n => n * 2;
    // var pow = n => n * n;
    // var reverseInt = n => n.toString().split('').reverse().join('') | 0
    // var piple = function(value) {
    //   var funcStack = []
    //   var proxy = new Proxy({}, {
    //     get(pipleObject, key) {
    //       if(key === 'get') {
    //         return funcStack.reduce((val, fn) => {
    //           return fn(val)
    //         }, value)
    //       }
    //       funcStack.push(window[key])
    //       return proxy
    //     }
    //   })
    //   return proxy
    // }
    // var res = piple(3).double.pow.reverseInt.get
    // console.log('res: ', res); // 63

    // 1.3下面的例子则是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。
    // var dom = new Proxy({}, {
    //   get(target, key) {
    //     return function(attr, ...children) {
    //       let el = document.createElement(key)
    //       for(let k of Object.keys(attr)) {
    //         el.setAttribute(k, attr[k])
    //       }
    //       // console.log(children, '====children');
    //       for(let c of children) {
    //         // el.innerHTML = c
    //         // el.textContent = c
    //         if(typeof c === 'string') {
    //           c = document.createTextNode(c)
    //         }
    //         el.appendChild(c)
    //       }
    //       return el
    //     }
    //   }
    // })
    // const el = dom.div({},
    //   'Hello, my name is ',
    //   dom.a({ href: '//example.com' }, 'Mark'),
    //   '. I like:',
    //   dom.ul({},
    //     dom.li({}, 'The web'),
    //     dom.li({}, 'Food'),
    //     dom.li({}, '…actually that\'s it')
    //   )
    // );
    // console.log(el, '===el');
    // document.body.appendChild(el)

    // 1.4get方法的第三个参数的例子，它总是指向【原始的读操作所在的那个对象】，一般情况下就是 Proxy 实例
    // var proxy = new Proxy({}, {
    //   get(t, k, receiver) {
    //     return receiver
    //   }
    // })
    // console.log(proxy.getReceiver === proxy); // true
    // var o = Object.create(proxy)
    // console.log(' o.d === d: ',  o.d === o); // true

    // 1.5如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。
    // var t = Object.defineProperties({}, {
    //   foo: {
    //     value: 234,
    //     enumerable: true,
    //     configurable: false,
    //     writable: false
    //   }
    // })
    // // console.log(t);
    // var proxy = new Proxy(t, {
    //   get(target, k) {
    //     return k
    //     // return target[k]
    //   }
    // })
    // console.log('proxy.fo: ', proxy.fo); // fo
    // console.log('proxy.foo: ', proxy.foo); // TypeError【get里返回target[key]就好了】




    // 2.set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。
    // 2.1假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求
    // var validator = {
    //   set(target, key, val, receiver) {
    //     if(key === 'age') {
    //       if(!Number.isInteger(val)) {
    //         throw new TypeError('The age is not an integer');
    //       }
    //       if(val > 200) {
    //         throw new RangeError('The age seems invalid');
    //       }
    //     }
    //     target[key] = val
    //     return true
    //   }
    // }

    // var proxy = new Proxy({}, validator)
    // // proxy.age = 12 // ok
    // // proxy.age = -12 // ok
    // // proxy.age = -12.2 // TypeError
    // // proxy.age = 201 // RangeError
    // proxy.age = 0 // ok
    // console.log(proxy);

    // 2.2有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。
    // 结合get和set方法，就可以做到防止这些内部属性被外部读写
    // function invariant(key, action) {
    //   if(key[0] === '_') {
    //     throw new Error(`Invalid attempt to ${action} private "${key}" property！`)
    //   }
    // }
    // const handler = {
    //   get(target, key, receiver) {
    //     // return target[key]
    //     invariant(key, 'get')
    //     return Reflect.get(target, key)
    //   },
    //   set(target, key, value, receiver) {
    //     invariant(key, 'set')
    //     // target[key]= value
    //     Reflect.set(target, key, value)
    //     // return false
    //   }
    // }
    // const t = {}
    // const proxy = new Proxy(t, handler)
    // proxy.age = 12;
    // console.log(proxy);
    // // console.log(t, 't');
    // // console.log(proxy._age );
    // // proxy._age = 10

    // 2.3set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身，请看下面的例子
    // const handler = {
    //   set(target, key, value, receiver) {
    //     target[key] = receiver
    //     // return true
    //   }
    // }
    // const proxy = new Proxy({}, handler)
    // const myobj = {}
    // Object.setPrototypeOf(myobj, proxy)
    // myobj.foo = 'foo'
    // console.log(myobj, '=myobj');
    // // console.log(myobj.a); // undefined
    // console.log(myobj.foo === myobj); // true


    'use strict'

    // 2.4如果目标对象自身的某个属性不可写，那么set方法将不起作用。
    // const obj = {}
    // Object.defineProperty(obj, 'foo',{
    //   value: 'bar',
    //   // writable: true,
    //   writable: false,
    //   // configurable: true
    // })
    // const proxy = new Proxy(obj, {
    //   set(t, k, v, r) {
    //     // console.log(t === obj); // true
    //     t[k] = v
    //     return true
    //   }
    // })  
    // proxy.name = 'jack'
    // console.log(proxy);
    // proxy.foo = 'bazz' // 严格模式报错：Cannot assign to read only property 'foo' of object '#<Object>'
    // console.log(proxy);


    // 3.apply方法拦截函数的调用、call和apply操作。
    // apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组
    // function fn() { return 'I\'m the target' }
    // const p = new Proxy(fn, {
    //   apply(target, ctx, args) {
    //     console.log('target, ctx, args: ', target, ctx, args);
    //     // return 'I am the proxy'
    //     return Reflect.apply(...arguments)
    //   }
    // })

    // console.log('p(1,2,4): ', p(1,2,4)); // I am the proxy
    // // p.call({o: 'age'}, 2,3,4)
    // // p.apply({o: 'age'}, [2,3,4])

    // demo3.1 下面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。
    // const twice = {
    //   apply(t, ctx, args) {
    //     return Reflect.apply(...arguments) * 2
    //   }
    // }
    // const sum = (x, y) => x + y
    // const proxy = new Proxy(sum, twice)
    // console.log('proxy(1,3): ', proxy(1,3)); //8
    // console.log('proxy(1,3): ', proxy.call(null, 4,5)); //18
    // console.log('proxy(1,3): ', proxy.apply(null, [5,10])); //30
    // // 另外，直接调用Reflect.apply方法，也会被拦截。
    // console.log('Reflect.apply(proxy, null, [,11,10]): ', Reflect.apply(proxy, null, [11,10])); // 42


    // 4.has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。
    // has()方法可以接受两个参数，分别是目标对象、需查询的属性名。
    // const handler = {
    //   has(target, key) {
    //     if(key[0] === '_') {
    //       return false
    //     }
    //     return key in target
    //   }
    // }
    // const o = {_prop: 'private', foo: 'ok foo'}
    // const p = new Proxy(o, handler)
    // // console.log('p.o: ', p.foo); //  ok foo
    // // console.log('p.o: ', p._prop); // private
    // console.log('foo' in p); // true
    // console.log('_prop' in p); // false

    // // 虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。
    // for(let key in p) {
    //   console.log(key, '---k');// _prop ---k;foo ---k
    // }

    // 如果原对象不可配置或者禁止扩展，这时has()拦截会报错。
    // const o = {a: 10}
    // Object.preventExtensions(o)
    // // o.a = 12
    // // console.log(o.a); // 12
    // // o.b = 13
    // // console.log(o); // TypeError: Cannot add property b, object is not extensible

    // const p = new Proxy(o, {
    //   has(t, k) {
    //     return false
    //   }
    // })

    // console.log(p.s); // undefined
    // console.log(p.a); // 10
    // console.log('a' in o);// true
    // console.log('a' in p);//TypeError: 'has' on proxy: trap returned falsish for property 'a' but the proxy target is not extensible

    // 上面代码中，obj对象禁止扩展，结果使用has拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则has()方法就不得“隐藏”（即返回false）目标对象的该属性


    // 5.construct()方法用于拦截new命令，下面是拦截对象的写法。
    // construct()方法可以接受三个参数。
    // target：目标对象。
    // args：构造函数的参数数组。
    // newTarget：创造实例对象时，new命令作用的构造函数（下面例子的p）。

    // 由于construct()拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。
    // const handler = {
    //   construct(target, args, newTarget) {
    //     // console.log(newTarget === p); // true
    //     // console.log('target, args, newTarget: ', target, args, newTarget);

    //     // 注意，construct()方法中的this指向的是handler，而不是实例对象。【前提是construct不能是箭头函数】
    //     console.log(this ===  handler); // true
    //     return {v: args[0] * 10} // 必须返回一个对象
    //   },
    //   name: 'tom'
    // }
    // const p = new Proxy(function(){}, handler)
    // console.log(new p(1,2,3,4));

    // 6.deleteProperty()方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。
    // function invariant(key, action) {
    //   if(key[0] === '_') {
    //     throw new Error(`Invalid attempt to ${action} private "${key}" property`)
    //   }
    // }  
    // const handler = {
    //     deleteProperty(t, k) {
    //       invariant(k, 'delete')
    //       delete t[k]
    //       return true
    //     }
    //   }
    //   // const t = {_p: 'pri', a: 12}
    //   const t2 = {_p: 'pri', a: 12}
    //   Object.defineProperty(t2, 'b', {
    //     value: 'tom',
    //     configurable: false // 目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。
    //   })
    //   // const p = new Proxy(t, handler)
    //   const p = new Proxy(t2, handler)

    //   console.log(p);
    //   delete p.a
    //   console.log(p);
    //   // delete p.b //  TypeError: Cannot delete property 'b' of #<Object>
    //   // console.log(p); 
    //   // delete p._p
    //   // console.log(p);


    // 7.defineProperty()方法拦截了Object.defineProperty()操作。
    // const handler = {
    //   defineProperty(target, key, descriptor) {
    //     console.log('target, key, descriptor: ', target, key, descriptor);
    //     Reflect.defineProperty(target, key, descriptor)
    //     // return false
    //     return true
    //   }
    // }
    // const t = {a: 1}
    // // Object.preventExtensions(t)
    // Object.defineProperty(t, 'a', {
    //   value: 123,
    //   configurable: false,
    //   writable: false
    // })
    // const p = new Proxy(t, handler)
    // p.foo ='foo'
    // console.log(p);
    // p.a ='as'
    // console.log(p);


    // 9.getPrototypeOf()方法主要用来拦截获取对象原型
    // Object.prototype.__proto__
    // Object.prototype.isPrototypeOf()
    // Object.getPrototypeOf()
    // Reflect.getPrototypeOf()
    // instanceof

    // var proto = {};
    // // 如果目标对象不可扩展（non-extensible）， getPrototypeOf()方法必须返回目标对象的原型对象。
    // const t = {}
    // Object.preventExtensions(t)
    // var p = new Proxy(t, {
    //   getPrototypeOf(target) {
    //     return target.__proto__;
    //     return proto;
    //   }
    // });
    // console.log('Object.getPrototypeOf(p) === proto: ', Object.getPrototypeOf(p) === proto);


    // 10.isExtensible()方法拦截Object.isExtensible()操
    // const t = {}
    // Object.preventExtensions(t)
    // var p = new Proxy(t, {
    //   isExtensible: function (target) {
    //     return false;
    //   }
    // });
    // console.log(' Object.isExtensible(p): ',  Object.isExtensible(p));


    // 11.setPrototypeOf()方法主要用来拦截Object.setPrototypeOf()方法。
    // const proto = {a: 1};
    // const t = {t: 'tt'}
    // // Object.preventExtensions(t)
    // const handler = {
    //   setPrototypeOf(target, proto) {
    //     console.log('target, proto: ', target, proto);
    //     Reflect.setPrototypeOf(target,proto)
    //     return true
    //   }
    // }
    // const p = new Proxy(t, handler)
    // Object.setPrototypeOf(p, proto);
    // console.log(p, '===p');


    // 3.Proxy.revocable()
    // Proxy.revocable()方法返回一个可取消的 Proxy 实例。
    // const t = {a: 1}
    // const handler = {}
    // const {proxy, revoke} = Proxy.revocable(t, handler)
    // proxy.foo = 23
    // console.log(proxy);
    // revoke()
    // console.log(proxy.foo, '2');//TypeError: Cannot perform 'get' on a proxy that has been revoked


    // 4.Web 服务的客户端
    const service = createWebService('http://example.com/data');
    // console.log(service.employees, '===service.employees');
    service.employees().then(json => {
      const employees = JSON.parse(json);
      console.log('json: ', employees);
    });
    function createWebService(baseUrl) {
      return new Proxy({}, {
        get(target, propKey, receiver) {
          return () => httpGet(baseUrl + '/' + propKey);
        }
      });
    }
    async function httpGet(url) {
      return await JSON.stringify(url)
    }
  </script>
</body>

</html>
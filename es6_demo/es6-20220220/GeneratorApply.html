<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generator Apply</title>
</head>

<body>
  <script>
    'use strict'

    // demo1
    function* gen(x) {
      try {
        var y = yield x + 2;
        console.log('y: ', y);
      } catch (error) {
        console.log('error: ', error);

      }
      return y;
    }

    // var g = gen(1);
    // console.log(g.next());
    // g.throw('err')
    // console.log(g.next(4));
    // console.log(g.next());


    // demo2
    function* gen() {
      const url = 'http://jsonplaceholder.typicode.com/posts?userId=5';
      const res = yield fetch(url)
      console.log(res, 22);
    }
    // var g = gen()
    // const result = g.next()
    // console.log('result: ', result);
    // result.value.then(response => {
    //   console.log(response, 2);
    //   return response.json()
    // }).then(data => {
    //   console.log(data, 3);
    //   console.log('g.next(data): ', g.next(data));
    // })


    // demo3：Thunk 函数转换器
    const Thunk2 = function (fn) {
      return function () {
        var args = Array.prototype.slice.call(arguments)
        return function (cb) {
          args.push(cb)
          fn.apply(this, args)
        }
      }
    }
    const Thunk = function (fn) {
      return function (...args) {
        return function (cb) {
          return fn.call(this, ...args, cb)
        }
      }
    }
    function f(a, cb) {
      cb(a)
    }
    // const ft = Thunk(f)
    // const ft = Thunk2(f) // 2
    // ft(2)(console.log) // 2


    // demo4: Thunkify 模块
    function thunkify(fn) {
      return function () {
        console.log(arguments, '--arguments');
        var args = new Array(arguments.length)
        console.log('args: ', args);
        var ctx = this
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
        return function (done) {
          var called
          args.push(function () {
            if (called) return
            called = true
            console.log(arguments, 'arguments2');
            done.apply(null, arguments)
          })

          try {
            fn.apply(ctx, args)
          } catch (error) {
            done(error)
          }
        }
      }
    }

    function fn(a, b, cb) {
      var sum = a + b;
      cb(sum)
      cb(sum)
    }

    // var ft = thunkify(fn)
    // var print = console.log.bind(console)
    // ft(1,3)(print) // 4


    // demo5:Thunk 函数的自动流程管理
    function* gen(v) {
      var a = yield function (f) {
        console.log('------step 1');
        return f(null, v)
      };
      console.log(a, '---a');
      var b = yield function (f) {
        console.log('------step 2');
        return f(null, a)
      };
      console.log(b, '----b');
      return b
    }

    function run(fn) {
      var g = fn(2)
      // debugger
      function next(err, data) {
        console.log(data, '----data');
        var r = g.next(data ? data * 2 : data)
        console.log('r: ', r);
        if (r.done) {
          console.log(r.value, '----vvv');
          return r.value
        }
        // debugger
        return r.value(next)
      }
      return next()
    }
    // console.log(' run(gen): ',  run(gen));

    // var g = gen(4)
    // var r = g.next(5)
    // console.log('r: ', r);
    // if(!r.done) {
    //   r.value(function(err, data1) {
    //     console.log(data1, '----data1');
    //     r = g.next(data1)
    //     console.log(r, '---r2');
    //     if(!r.done) {
    //       r.value(function(err2, data2) {
    //         console.log(data2, '----data2');
    //         r = g.next(data2)
    //         console.log(r, '----r3');
    //       })
    //     }
    //   })
    // }

    // var g = gen(4)
    // var r = g.next(5)
    // console.log(r, '---r1');
    // if(!r.done) {
    //   // r.value()
    //   r = g.next(6)
    //   console.log(r, '----r2');
    //   if(!r.done) {
    //     r = g.next(7)
    //     console.log(r, '----r 3');
    //   }
    // }


    // demo6:co 模块的源码
    // 1.首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。
    function co(gen) {
      // debugger
      var ctx = this

      // 2.在返回的 Promise 对象里面，co 先检查参数gen是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；
      // 如果不是就返回，并将 Promise 对象的状态改为resolved。
      return new Promise((resolve, reject) => {
        if (typeof gen === 'function') gen = gen.call(ctx)
        if (!gen || typeof gen.next !== 'function') return resolve(gen)

        // 3.接着，co 将 Generator 函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。
        onFulfilled()

        function onFulfilled(res) {
          console.log('res: ', res);
          var ret
          try {
            ret = gen.next(res)
            console.log('ret: sss', ret);
          } catch (e) {
            return reject(e)
          }
          // 4.最后，就是关键的next函数，它会反复调用自身。
          next(ret)
        }

        function onRejected(err) {
          var ret;
          try {
            ret = gen.throw(err)
          } catch (e) {
            reject(e)
          }
          next(ret)
        }

        function next(ret) {
          console.log('ret:33 ', ret);
          // 1.检查当前是否为 Generator 函数的最后一步，如果是就返回。
          if (ret.done) return resolve(ret.value)
          // 2.确保每一步的返回值，是 Promise 对象。
          var value = toPromise.call(ctx, ret.value)
          console.log('value: ', value);
          // 3.使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数。
          if (value && isPromise(value)) return value.then(onFulfilled, onRejected)
          // 4.在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为rejected，从而终止执行。
          return onRejected(
            new TypeError(
              'You may only yield a function, promise, generator, array, or object,'
              + 'but the following object was passed: "'
              + String(ret.value)
              + '"'
            )
          )
        }
        // function next(ret) {
        //   if(ret.done) return resolve(ret.value)
        //   return ret.value.then(onFulfilled)
        // }

      })
    }

    /**
     * convert a `yield`ed value into a promise
     * @param {Mixed} obj
     * @return {Promise}
    */
    function toPromise(obj) {
      if (!obj) {
        console.log(obj, '---1');
        return obj
      }
      if (isPromise(obj)) {
        console.log(obj, '----2');
        return obj
      }

      if (isGeneratorFunction(obj) || isGenerator(obj)) {
        console.log(obj, '----3');
        return co.call(this, obj)
      }
      if ('function' === typeof obj) {
        console.log(obj, '----4');
        return thunkToPromise.call(this, obj)
      }
      if (Array.isArray(obj)) {
        console.log(obj, '----5');
        return arrayToPromise.call(this, obj)
      }
      if (isObject(obj)) {
        console.log(obj, '----6');
        return objectToPromise.call(this, obj)
      }
      console.log(obj, '----7');
      return obj
    }

    var slice = Array.prototype.slice
    /**
     * convert a thunk to a promise
     * @param {Function} fn
     * @return {Promise}
    */
    function thunkToPromise(fn) {
      var ctx = this
      return new Promise((resolve, reject) => {
        fn.call(ctx, function (err, res) {
          if (err) return reject(err)
          if (arguments.length > 2) res = slice.call(arguments, 1)
          resolve(res)
        })
      })
    }


    /**
      * convert an array of `yieldable` to a promise
      * Use `Promise.all` internally
      * @param {Array} obj
      * @return {Promise}
     */
    function arrayToPromise(obj) {
      console.log(obj, '--obj33');
      var r = Promise.all(obj.map(toPromise, this))
      console.log('r:44 ', r);
      return r
    }

    /**
      * convert an object of `yieldable` to a promise
      * Use `Promise.all` internally
      * @param {Object} obj
      * @return {Promise}
     */
    function objectToPromise(obj) {
      console.log(obj, '=----obj');
      // 基于obj的妈构建一个新对象实例
      var results = new obj.constructor()
      var keys = Object.keys(obj)
      var promises = []
      for (let i = 0; i < keys.length; i++) {
        var key = keys[i]
        var promise = toPromise.call(this, obj[key])
        if (promise && isPromise(promise)) defer(promise, key)
        else results[key] = obj[key]
      }

      return Promise.all(promises).then(function () {
        console.log(results, '======results000');
        return results
      })

      function defer(promise, key) {
        console.log(key, '======key');
        // predefine the key in results
        results[key] = undefined
        promises.push(promise.then(function (res) {
          console.log(res, '=====res');
          results[key] = res
        }))
      }
    }

    /**
     *  check if `obj` is a generator
     * @param {Mixed} obj
     * @return {Boolean}
     *
    */
    function isGenerator(obj) {
      return typeof obj.next === 'function' && typeof obj.throw === 'function'
    }

    /**
     *  check if `obj` is a generator function
     * @param {Mixed} obj
     * @return {Boolean}
     *
    */
    function isGeneratorFunction(obj) {
      var constructor = obj.constructor
      if (!constructor) return false
      if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true
      return isGenerator(constructor.prototype)
    }

    /**
     * check if `obj` is a promise
     * @param {Object} obj
     * @return {Boolean}
    */
    function isPromise(obj) {
      return typeof obj.then === 'function'
    }

    /**
     * check for plain object
     * @param {Mixed} val
     * @return {Boolean}
    */
    function isObject(val) {
      return Object === val.constructor
    }


    // demo6：co处理并发的异步操作
    // 数组的写法
    // co(function* () {
    //   var res = yield [
    //     Promise.resolve(1),
    //     Promise.resolve(2),
    //   ]
    //   console.log(res);
    //   return res
    // }).then(r => console.log(r, '===r'))
    //   .catch(e => console.log(e, ''))
    //  对象的写法
    // co(function* () {
    //   var res = yield {
    //     a: Promise.resolve(1),
    //     b: Promise.resolve(2),
    //   }
    //   console.log(res);
    //   return res
    // }).then(r => console.log(r, '===r'))
    //   .catch(e => console.log(e, ''))


    // 下面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。
    // co(function* () {
    //   var values = [1, 2, 3];
    //   var s = yield values.map(somethingAsync);
    //   return s
    // }).then(r => console.log(r, '--r'))
    //   .catch(e => console.log(e, 'eee'))
    // function* somethingAsync(x) {
    //   // do something async
    //   return x
    // }
  </script>
</body>

</html>
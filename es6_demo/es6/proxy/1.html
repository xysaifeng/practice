<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Proxy</title>
    </head>
    <body>
        <script>
            //    'use strict';
            /*
            // 1.
            var o = {};
            var obj = new Proxy(o, {
                get(target, propertyName, receiver) {
                    console.log(`getting ${propertyName} `);
                    return Reflect.get(target, propertyName, receiver)
                },
                set(target, propertyName, value, receiver) {
                    // console.log('receiver: ', receiver === obj);
                    console.log(`setting ${propertyName} -- ${value}`);
                    return Reflect.set(target, propertyName, value, receiver)
                },
            })
            obj.name = 'tom';
            obj.age = '12';
            console.log(obj.age);
            obj.count = 1;
            obj.count ++;
            console.log(obj);
            console.log(o);
            */

            /*
            // 2.proxy实例也可作为其他对象的原型对象
            var p = new Proxy({}, {
                get(target, propKey){
                    return 33;
                }
            });
            var obj = Object.create(p);
            console.log(obj.s); // 33
            console.log(obj);
            */

            /*
            // 3.同一个拦截器函数，可以设置拦截多个操作：
            var handler = {
                get(target, name) {
                    if(name === 'prototype') {
                        return Object.prototype;
                    }
                    return 'hello ' + name;
                },
                apply(target, thisBinding, args) {
                    console.log(thisBinding, '====================== thisBinding'); // {a: 99}
                    console.log(args, '====================== args'); // [55, 66]
                    return args[0]
                },
                construct(target, arg) {
                    console.log(arg, '====================== arg');
                    return { value: arg[1] };
                }
            };
            var fp = new Proxy(function(x, y) {
                return x + y;
            }, handler);

            console.log(fp, '=========fp');
            console.log(fp(2, 4)); // 2
            var s = new fp(5, 6);
            console.log(s, '=================s');
            console.log(fp.prototype === Object.prototype); // true
            console.log(fp.foo); // hello foo
            // fp.call({a: 88}, 9,7) // error: TypeError: fp.call is not a function
            console.log(' Reflect.apply(fp, {a: 99}, [55, 66]);: ',  Reflect.apply(fp, {a: 99}, [55, 66])); // 55
            */


            /*
            // Proxy实例的方法
            // 1.get()该方法用于拦截某个属性的读取操作，可以接受三个参数，依次是目标对象，属性名和proxy实例本身（严格来说，是操作行为所针对的对象），其中最后一个参数可选。
            var person = {
                name: "张三",
            };
            var p = new Proxy(person, {
                get(target, propKey) {
                    if (propKey in target) {
                        return target[propKey];
                    }
                    // throw new ReferenceError('Prop name \'' + propKey + '\' does not exist')
                },
            });
            console.log(p.name); // 张三
            // console.log(p.a); //  ReferenceError: Prop name 'a' does not exist
            // 如果没有这个拦截函数，访问不存在的属性，只会返回undefined
            console.log(p.s); // r90 如果注释了这里是undefined
            console.log("------------------------");
            // get方法可以继承
            var proto = new Proxy(
                { a: 12 },
                {
                    get(target, propertyKey, receiver) {
                        // console.log('GET1 '+target);
                        console.log(target, "--");
                        console.log("GET2 " + propertyKey);
                        return target[propertyKey];
                    },
                }
            );
            var o = Object.create(proto, {
                name: {
                    writable: false,
                    value: "aqiuo",
                },
            });
            // console.log(o.foo); // 1 GET foo  2 undefined
            console.log(o); // ???????
            // console.log(o.__proto__ === proto, '============ compare'); // false
            // console.log(o.__proto__ === Object.prototype, '============ compare2'); // true
            // console.log(Reflect.ownKeys(o.__proto__));
            // console.log('--------------------');
            // console.log(o.name); // 读取自身的属性 不会打印 GET
            // console.log(o.a); //  读取原型上的的属性 会打印 GET a
            // 上面的代码中，拦截定义在prototype对象上面，所以如果读取o对象继承的属性时（上面是 a）,拦截会生效

            // 使用get拦截,实现数组读取负数索引
            console.log("------ 数组读取负数索引");
            function createArr(...args) {
                let handler = {
                    //    法一：直接从target中取值
                    // get(target, propKey, receiver) { // receiver proxy实例本身
                    //     let index = +propKey;
                    //     if(index < 0) {
                    //         propKey = target.length + index;
                    //     }
                    //     return target[propKey]
                    // }
                    //    法二：使用Reflect取值
                    get(target, propKey, receiver) {
                        // receiver proxy实例本身
                        let index = +propKey;
                        if (index < 0) {
                            propKey = target.length + index;
                        }
                        return Reflect.get(target, propKey, receiver);
                    },
                };
                let target = [];
                target.push(...args);
                return new Proxy(target, handler);
            }
            var arr = createArr(3, 4, 5, 6);
            console.log(arr[2]); // 5
            console.log(arr[-2]); // 5

            // 利用Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作：
            console.log("--------------- 链式操作");
            var double = (n) => n * 2;
            var pow = (n) => n * n;
            var reverseInt = (n) => String(n).split("").reverse().join("") || 0;
            var pipe = function (value) {
                var funcStack = [];
                var oproxy = new Proxy(
                    {},
                    {
                        get(pipeObj, fnName) {
                            if (fnName === "get") {
                                return funcStack.reduce((acc, fn) => {
                                    return fn(acc);
                                }, value);
                            }
                            funcStack.push(window[fnName]);
                            return oproxy;
                        },
                    }
                );
                return oproxy;
            };
            console.log(pipe(3).double.pow.reverseInt.get); // 63
            // 上面代码设置了Proxy后，达到了将函数名链式调用的效果

            // 利用get拦截，实现一个生成各种dom节点的通用函数dom;
            console.log("----------------- 通用函数dom");
            const dom = new Proxy(
                {},
                {
                    get(target, propKey) {
                        return function (attrs = {}, ...children) {
                            const el = document.createElement(propKey);
                            for (let prop of Object.keys(attrs)) {
                                el.setAttribute(prop, attrs[prop]);
                            }
                            for (let child of children) {
                                if (typeof child === "string") {
                                    child = document.createTextNode(child);
                                }
                                el.appendChild(child);
                            }
                            return el;
                        };
                    },
                }
            );
            const el = dom.div(
                {},
                "Hello, my name is ",
                dom.a({ href: "//example.com" }, "Mark"),
                ". I like:",
                dom.ul(
                    {},
                    dom.li({}, "The web"),
                    dom.li({}, "Food"),
                    dom.li({}, "…actually that's it")
                )
            );
            console.log(el);
            document.body.appendChild(el)

            // 下面是get方法的第三参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是Proxy的实例。
            console.log('=================================== hr');
            let o2 = {};
            const proxy = new Proxy(o2, {
                get(target, propKey, receiver) {
                    console.log(this);
                    console.log(receiver);
                    console.log(target === o2); // true
                    console.log(receiver === this); // false
                    console.log(receiver === proxy); // true
                    return receiver;
                },
                set() {

                }
            });
            console.log(proxy.s === proxy); // true
            // 上面代码中，proxy对象的s属性是proxy提供的，所以receiver指向proxy对象

            console.log('======================== hr2');
            const p2 = new Proxy({}, {
                get(target, propKey, receiver) {
                    return receiver;
                }
            });
            const d = Object.create(p2);
            console.log(d.a === p2); // false
            console.log(d.a === d); // true
            // ** 上面代码中，d对象本身没有a属性，所以读取d.a的时候，回去d的原型p2对象上去找。这时，receiver就指向d,代码原始读操作所在的那个对象。

            // 如果一个属性不可配置*且*不可写，则Proxy不能修改该属性，否则通过Proxy对象访问该属性会报错：
            console.log('============================== hr3');
            const t = {};
            Reflect.defineProperty(t, 'foo', {
                value: 10,
                enumerable: true,
                writable: false,
                configurable: false
            });
            console.log(t, '=============t');
            const p3 = new Proxy(t, {
                get(target, key) {
                    // return 'abc' + target[key] ? target[key] : '';
                    // return target[key];
                    return 'abc' + target[key];
                }
            });
            console.log(p3.a); // 'abcundefined'
            console.log(p3.foo); // TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected '10' but got 'abc')
            */


            /*
            // 2.set():用来某个属性的赋值操作，接受四个参数，依次为目标对象，属性名， 属性值， Proxy实例本身，其中最后一个参数可选。
            // 假如person对象有个age属性，该属性应该是一个不大于200的整数，那么可以使用Proxy保证age的属性值符合要求。
            let validator = {
                set(target, prop, value) {
                    if (prop === "age") {
                        if (!Number.isInteger(value)) {
                            throw new TypeError("value id needed Integer");
                        }
                        if (value > 200) {
                            throw new RangeError("the age seems invalid");
                        }
                        target[prop] = value;
                        return true;
                    }
                },
            };
            let person = new Proxy({}, validator);
            // person.a = 10; // 无反应
            // person.age = 310 // RangeError: the age seems invalid
            // person.age = '310' // TypeError: value id needed Integer
            person.age = -1;
            console.log(person);

            // 有时我们会在对象上设置内部属性，属性名的第一个字符串是下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以防止这些内部属性被外部读写。
            const t = {};
            let handler = {
                get(target, prop) {
                    invariant(prop, "get");
                    return target[prop];
                },
                set(target, prop, value) {
                    invariant(prop, "set");
                    target[prop] = value;
                },
            };
            const p = new Proxy(t, handler);
            function invariant(prop, action) {
                if (prop.startsWith("_")) {
                    throw new Error(
                        `Invalid attempt to ${action} privid "${prop}" property`
                    );
                }
            }

            // p._a; // Error: Invalid attempt to get privid "_a" property
            // p._a = 10; // Error: Invalid attempt to set privid "_a" property
            // 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。

            // 下面是set方法的第四个参数的例子：
            console.log("--------------------------------------h1");
            const p1 = new Proxy(
                {},
                {
                    set(target, prop, value, receiver) {
                        target[prop] = receiver;
                    },
                }
            );
            p1.foo = "aqiu";
            console.log(p1.foo === p1); // true
            // 上面代码中，set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是Proxy实例本身，请看下面的例子：
            const p2 = new Proxy(
                {},
                {
                    set(target, prop, value, receiver) {
                        target[prop] = receiver;
                    },
                }
            );
            let myObj = {};
            let r = Reflect.setPrototypeOf(myObj, p2);
            console.log(r, "================r"); // true
            myObj.fzz = 100;
            console.log(myObj.fzz === myObj); // true
            // 上面代码中，设置myObj.fzz属性的值时，myObj并没有fzz属性，隐藏引擎会到myObj的原型链去找fzz属性。myObj的原型对象p2是一个Proxy实例，设置它的foo属性会触发set方法，这时，第四个参数receiver就指向原始赋值行为的myObj对象。

            // 注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。
            console.log("------------------------------------------ h2");
            const obj = {};
            Reflect.defineProperty(obj, "foo", {
                value: "hello",
                writable: false,
                configurable: true,
            });
            const p3 = new Proxy(obj, {
                set(target, prop, value, receiver) {
                    // "use strict";
                    console.log(prop, value, "========================898989");
                    target[prop] = value;
                    // return true
                },
            });
            console.log(p3, "==================p3");
            p3.foo = 100;
            console.log(p3.foo); // hello
            // 上面代码中，obj.foo属性不可写，Proxy对这个属性的set代理不会生效。注意严格模式下，会报错： TypeError: Cannot assign to read only property 'foo' of object '#<Object>'
            // 如果row 10 启用严格模式，则报错：TypeError: 'set' on proxy: trap returned falsish for property 'foo'
            */


            /*
            // 3.apply()方法拦截函数的调用、call和apply的操作。接受三个参数，分别是目标对象，目标对象的上下文对象（this）和目标对象的参数数组。
            var handler = {
                apply(target, context, args) {
                    console.log('args: ', args);
                    console.log('context: ', context);
                    console.log('target: ', target);
                    console.log(...arguments);
                    return Reflect.apply(...arguments);
                }
            }
            // eg:
            var target = function() { return 'i am the target' };
            var handler2 = {
                apply: function() {
                    console.log(arguments);
                    return 'i am the proxy'
                }
            }
            // var p = new Proxy(target, handler);
            var p = new Proxy(target, handler2);
            // console.log('p(): ', p.apply({a: 2}, [4,5])); // i am the target
            console.log('p(): ', p.apply({a: 2}, [4,5])); // 'i am the proxy'
            // 上面代码中，变量p是Proxy的实例，当它作为函数调用时（p()）,就会被apply方法拦截，返回一个字符串。

            // 下面是另一个例子：
            console.log('-------------- h1');
            var twice = {
                apply(target, ctx, args) {
                    console.log('ctx: ', ctx); // {a: 43}
                    console.log('target: ', target); // sum
                    console.log('args: ', args); // [4, 9]
                    // return target(...args)
                    return Reflect.apply(...arguments) * 2;
                }
            }
            var sum = function(x, y) {
                return x + y;
            }
            const p2 = new Proxy(sum, twice);
            // console.log(p2(1,2)); // 6
            // console.log(p2.call(null, 4,5)); // 18
            // console.log(p2.apply(null, [5,5])); // 20
            // 另外直接调用Reflect.apply方法，也会被拦截
            var r = Reflect.apply(p2, {a: 43}, [4,9] )
            console.log('r: ', r); // 26
            */


            /*
            // 4.has()
            // has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会很生效。典型的操作就是in运算符。
            // has方法有两个参数，分别是目标对象和要查询的属性名。
            var target = {
                _prop: 's',
                prop: 12
            };
            target.__proto__ = {a: 100}
            var handler = {
                has(target, key) {
                    if(key[0] === '_') return false;
                    // return key in target;
                    return Reflect.has(target, key);
                }
            };
            var p = new Proxy(target, handler);
            console.log('p: ', p);
            console.log('s' in p); // false
            console.log('prop' in p); // true
            console.log('_prop' in p); // false
            console.log('a' in p, '-----'); // true
            console.log('_prop' in target); // true
            // 上面代码中，如果原对象的属性名的第一个字符是下划线，p.has就会返回false,从而不被in运算符发现。

            // 如果原对象不可配置或禁止扩展，这时has会报错：
            console.log('------------------ h1');
            // var o = {a: 1};
            // Object.preventExtensions(o);

            var o = {b: 'hhh'};
            Reflect.defineProperty(o, 'a', {
                value: 100,
                configurable: false
            })

            console.log(Object.getOwnPropertyDescriptor(o, 'a'));
            const p2 = new Proxy(o, {
                has(target, key) {
                    // return key in target
                    return false
                }
            })
            console.log('b' in p2); // false
            // console.log('a' in p2); // 报错
            // 上面代码中，o对象禁止扩展，结果使用has拦截就会报错。也就是说，如果某个属性不可配置（或目标对象禁止扩展），则has方法就不得‘隐藏’（即返回false）目标对象的该属性。

            // 值得注意的是，has方法拦截的是HasProperty操作，而不是,即has方法不判断一个属性是对象自身属性还是继承属性，见row441.

            // 另外，虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效。
            console.log('------------------------- h2');
            let stu1 = { name: '张三', score: 55 };
            let stu2 = { name: '李四', score: 99 };
            let handler3 = {
                has(target, key) {
                    if(key === 'score' && target[key] < 60) {
                        console.log(`${target.name}的成绩不及格`);
                        return false
                    }
                    return key in target;
                }
            };
            let sproxy1 = new Proxy(stu1, handler3);
            let sproxy2 = new Proxy(stu2, handler3);
            console.log('score' in sproxy1); // false
            console.log('score' in sproxy2); // true

            for(let p in sproxy1) {
                console.log(p);
            }
            for(let p in sproxy2) {
                console.log(sproxy2[p]);
            }
            // 上面代码中has拦截只对in运算符生效，对for...in循环不生效，导致不符合要求的属性没被for...in循环排出掉。
            */


            /*
            // 5.construct方法用于拦截new命令，下面是拦截对象的写法：
            var handler = {
                construct(target, args, newTarget) {
                    return new target(...args);
                }
            }
            // construct方法接受三个参数：target：目标对象，args:构造函数的参数对象，newTarget:创建实例对象时，new命令作用的构造函数（下面是p）;
            var p = new Proxy(function() {}, {
                construct: function(target, args, newTarget) {
                    console.log(target, '==============tttt')
                    console.log(args, '===============args');
                    console.log(newTarget, '===============newTarget');
                    return { value: args[0]}
                }
            });
            console.log(new p(3).value); // 30

            // cosntruct方法的返回必须是一个对象，否则会报错。
            var p2 = new Proxy(function() {}, {
                construct(target, args) {
                    return 'ad';
                }
            })
            // console.log(new p2(9)); //  TypeError: 'construct' on proxy: trap returned non-object ('ad')
            */

            /*
            // 6.deleteProperty()
            // deleteProperty方法用于拦截delete操作。如果这个方法返回false或者抛出错误，当前属性就无法被delete命令删除。
            var target = {
                _prop: 'a',
                prop: 'b'
            };
            Reflect.defineProperty(target, '_key', {
                value: 99,
                configurable: false
            })
            var handler = {
                deleteProperty(target, key) {
                    // 'use strict'
                    // return false
                    invariant(key, 'delete');
                    delete target[key];
                    return false;
                }
            }
            function invariant(key, action) {
                if(key[0] === '_') {
                    throw new Error(`Invalidate attempt to ${action} private "${key}" property`);
                }
            }
            var p = new Proxy(target, handler);
            // delete p._prop
            // console.log('delete p._prop: ', delete p._prop); // Error: Invalidate attempt to delete private "_prop" property
            // 上面代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。

            // delete p._key; // 严格模式下：目标对象自身的不可配置的属性，不能被deleteProperty方法删除，否则报错。否则会禁默失败（删除失败且没有提示信息）
            */

            
            /*
            // 7.defineProperty()
            // 该方法拦截了Object.defineProperty()操作。
            var target = {};
            
            // Reflect.preventExtensions(target);

            Reflect.defineProperty(target, 'name', {
                value: 'tom',
                writable: false,
                configurable: false
            })
            var handler = {
                defineProperty(target, key, descriptor) {
                    'use strict'
                    console.log('descriptor: ', descriptor);
                    console.log('target: ', target);
                    console.log('key: ', key);
                    return Object.defineProperty(target, key, descriptor)
                    return true;
                }
            }
            var p = new Proxy(target, handler);
            p.foo = '100';
            p.name = 'lisan';
            console.log(p);
            // 上面代码中，defineProperty()方法内部没有任何操作，只返回false，导致添加新属性总是无效（p.foo = 100）。注意，这里的false只是用来提示操作失败，本身并不能阻止添加新属性。
            // 注意：如果目标对象不可扩展（non-extensible），则defineProperty()不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable）,则defineProperty方法不得改变这两个设置。(如果name的writable为false，则handler的defineProperty不会拦截，即不会打印console)
            */


            /*
            // 8.getOwnPropertyDescriptor()
            // 该方法拦截Object.getOwnPropertyDescriptor，返回一个属性描述对象或undefined。
            var handler = {
                getOwnPropertyDescriptor(target, key) {
                    if(key[0] === '_') return;
                    return Object.getOwnPropertyDescriptor(target, key);
                }
            };
            var target = { _foo: 'foo', bar: 'bar' };
            var p = new Proxy(target, handler);
            console.log(Reflect.getOwnPropertyDescriptor(p, 'name')); // undefined
            console.log(Reflect.getOwnPropertyDescriptor(p, '_foo')); // undefined
            console.log(Reflect.getOwnPropertyDescriptor(p, 'bar')); // {value: "bar", writable: true, enumerable: true, configurable: true}
            // handler.getOwnPropertyDescriptor()方法对于第一个字符为下划线的属性名会返回undefined。
            */


            /*
            // 9.getPrototypeOf()
            // 该方法用来获取原型对象，拦截一下操作：
            // Object.prototype.__proto__
            // Object.prototype.isPrototypeOf()
            // Object.getPrototypeOf()
            // Reflect.getPrototypeOf()
            // instanceof
            var proto = {a:1};
            var target = {b: 12}
            // Reflect.preventExtensions(target)
            Object.seal(target)
            var p = new Proxy(target, {
                getPrototypeOf(target) {
                    console.log(target);
                    // return 1; // TypeError: 'getPrototypeOf' on proxy: trap returned neither object nor null
                    // return null
                    // return proto; // TypeError: 'getPrototypeOf' on proxy: proxy target is non-extensible but the trap did not return its actual prototype
                    return Reflect.getPrototypeOf(target); // 必须返回目标对象的原型对象。
                }
            })
            console.log(Object.getPrototypeOf(p)); // 
            console.log(Object.getPrototypeOf(p) === proto); // true
            // getPrototypeOf()方法拦截Object.getPrototypeOf()，返回proto对象。

            // 注意：getPrototypeOf()方法的返回值必须是对象或者null，否则会报错。如果目标对象不可扩展（non-extensible），getPrototypeOf()方法必须返回目标对象的原型对象。
            */


            /*
            // 10.isExtensible()
            // 该方法拦截Object.isExtensible()操作。
            var t = {};
            // Reflect.preventExtensions(t) // error
            var p = new Proxy(t, {
                isExtensible(target) {
                    console.log('called');
                    // return true; // 如果返回true，则目标对象t不能被禁止扩展或者代理实例对象p不能被禁止扩展，否则报错
                    return false; // 如果返回false，则目标对象t是禁止扩展或者代理实例对象p是禁止扩展状态，否则报错
                }
            })
            // Reflect.preventExtensions(p) // error
            console.log(Object.isExtensible(p)); // true
            // 上面代码设置了isExtensible方法，在调用Object.isExtensible时会打印called
            // 注意：该方法只能返回布尔值，否则返回值会自动转化为布尔值。
            // 该方法有一个强制性，他的返回值必须与目标对象的isExtensible属性一致，否则会抛出错误。
            // Object.isExtensible(proxy) === Object.isExtensible(target)
            */


            /*
            // 11.ownKeys()
            // 用来拦截对象自身属性的读取操作，拦截以下操作：
            // Object.getOwnPropertyNames()
            // Object.getOwnPropertySymbols()
            // Object.keys()
            // for...in循环

            // 拦截Object.keys()
            var target = {
                a: 'a',
                b: 'b',
                c: 'c',
            };
            var p = new Proxy(target, {
                ownKeys(target) {
                    console.log(target, 'target');
                    // return [1] // TypeError: 1 is not a valid property name
                    // return [false] // TypeError: 1 is not a valid property name
                    // return [] // []
                    // return ['1'] // []
                    // return ['as'] // []
                    // return 2 // TypeError: CreateListFromArrayLike called on non-object 返回的不是数组
                    // return ['c', 1] // TypeError: 1 is not a valid property name
                    return ['c', ] // ['c']
                }
            })
            console.log(Object.keys(p));
            // 上面代码中拦截了对于target对象的Object.keys()操作，只返回a、b、c三个属性的c属性。
            // 规则：1.必须返回数组；2.返回数组如果有长度，则数组元素是有效的属性键名，如果是无效键名或包含无效键名如：[1],[false]为无效键名,均报错。3、如果包含的是有效键名但该键名不在目标对象自身属性中如：['as'],则返回一个空数组。

            // 下面拦截第一个字符为下划线的属性名。
            let t = {
                _foo: 'foo',
                _bar: 'bar',
                baz: 'baz',
            };
            let h = {
                ownKeys(target) {
                    return Reflect.ownKeys(target).filter(key => key[0] !== '_')
                }
            };
            let p2 = new Proxy(t, h);
            for(let key of Object.keys(p2)) { // 拦截Object.keys
                console.log(key, p2[key] );
            }
            for(let key in p2) { // l拦截for...in
                console.log(key );// baz
            }
            // 拦截Object.getOwnPropertyNames
            console.log(Object.getOwnPropertyNames(p2)); // ['baz']

            // 注意，使用Object.keys()和for...in循环方法时，有三类属性会被ownkeys()方法自动过滤，不会返回。
            // 目标对象上不存在的属性
            // 属性名为Symbol值
            // 不可遍历（enumerabel）的属性
            console.log('----------------------------------------------h1');
            let obj = {
                a: 1,
                b: 2,
                c: 3,
                [Symbol.for('secret')]: 4
            };
            Reflect.defineProperty(obj, 'key', {
                value: 'static',
                enumerable: false,
                writable: true,
                configurable: true
            });
            let h2 = {
                ownKeys(target) {
                    return ['a', 'd', Symbol.for('secret'), 'key'];
                }
            }
            let p3 = new Proxy(obj, h2);
            console.log(Object.keys(p3)); // ['a']
            // 上面代码中，ownKeys()方法之中，显示返回不存在的属性('d')、Symbol值( Symbol.for('secret'))、不可遍历的属性(key)，结果都被自动过滤掉。
            console.log(Object.getOwnPropertyNames(p3)); // ['a', 'd', 'key']
            console.log(Object.getOwnPropertySymbols(p3)); // [Symbol(secret)]
            for(let key in p3) {
                console.log(key, p3[key]); // a 1
            }
            console.log('----------------------------------------------h2');

            // ownKeys()方法拦截Object.getOwnPropertyNames()
            let p4 = new Proxy({}, {
                ownKeys(target) {
                    return ['a', 'b']
                }
            });
            console.log(Object.getOwnPropertyNames(p4)); // ['a', 'b'];
            console.log('----------------------------------------------h3');

            // ownKeys()方法拦截for...in循环，和拦截Object.keys()类似。
            const o = {hello: 'world'};
            const p5 = new Proxy(o, {
                ownKeys(target) {
                    return ['a', 'b'];
                }
            })
            for(let key in p5) {
                console.log(key, '000'); // 没有任何输出
            }
            // 上面代码中，ownKeys()指定只返回a和b属性，由于o没有这两个属性，因此for...in循环不会有任何输出。


            // ownKeys()方法返回的数组成员，只能是字符串或Symbol值。如果有其他类型值或者返回的根本不是数组，就会报错。
            console.log('----------------------------------------------h4');
            const o3 = {};
            const p6 = new Proxy(o3, {
                ownKeys(target) {
                    // TypeError: 123 is not a valid property name
                    // return [123, true, undefined, null, {}, [], () => {}];

                    // TypeError: undefined is not a valid property name
                    // return [, true, undefined, null, {}, [], () => {}];

                    // TypeError: true is not a valid property name
                    // return [true, undefined, null, {}, [], () => {}];

                    // TypeError: undefined is not a valid property name
                    // return [ undefined, null, {}, [], () => {}];

                    // TypeError: null is not a valid property name
                    // return [ null, {}, [], () => {}];

                    // TypeError: #<Object> is not a valid property name
                    // return [ {}, [], () => {}];

                    // TypeError: [object Array] is not a valid property name
                    // return [ [], () => {}];

                    
                    // TypeError: () => {} is not a valid property name
                    // return [() => {}];
                    
                    // return '23' // TypeError: CreateListFromArrayLike called on non-object

                    return []
                }
            });
            Object.getOwnPropertyNames(p6)
            // 上面代码中，ownKeys()方法虽然返回一个数组，但是每一个数组成员都不是字符串或Symbol值，因此就报错了。

            console.log('----------------------------------------------h5');
            // 如果目标对象自身包含不可配置的属性，则该属性必须被ownKeys()方法返回，否则报错。
            const o4 = {};
            Reflect.defineProperty(o4, 'a', {
                value: 'hhh',
                enumerable: true,
                writable: true,
                configurable: false
            });
            let p7 = new Proxy(o4, {
                ownKeys(target) {
                    // return ['b'] // 报错
                    return ['a', 'b'] // ['a', 'b']
                }
            })
           console.log( Object.getOwnPropertyNames(p7));// TypeError: 'ownKeys' on proxy: trap result did not include 'a'
           console.log('----------------------------------------------h5');

            // 另外，如果目标对象是不可扩展的(non-extensible)，这时ownKeys()方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。
            let o5 = {
                a: 11,
                b: 22
            };
            Object.preventExtensions(o5);
            let p8 = new Proxy(o5, {
                ownKeys(target) {
                    // return ['a'] // 少了属性：TypeError: 'ownKeys' on proxy: trap result did not include 'b'
                    // return ['a', 'b', 'c'] // 多了属性： TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible
                    return ['a', 'b'] // ok: ['a', 'b']
                }
            });
            console.log(Object.getOwnPropertyNames(p8));
            // 上面代码中，obj对象是不可扩展的，这时ownKeys()方法返回的数组之中，包含了o5对象多余或漏掉的属性，导致报错。
            */


            /*
            // 12.preventExtensions()
            // preventExtensions()方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。

            // 这个方法有一个限制，只有目标对象不可扩展时(即Object.isExtensible(proxy)为false),proxy.preventExtensions才能返回true,否则会报错。
            var t = {};
            Object.preventExtensions(t);
            var p = new Proxy(t, {
                preventExtensions(target) {
                    // return false; // 目标对象可扩展时，返回false报错：TypeError: 'preventExtensions' on proxy: trap returned falsish
                    // return true; // 目标对象可扩展时，返回true报错： TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible
                    
                    // return false; // 目标对象不可扩展，返回false报错： TypeError: 'preventExtensions' on proxy: trap returned falsish
                    return true; // 目标对象不可扩展，返回true，不报错
                }
            })
            console.log(Object.preventExtensions(p)); // Proxy {}
            // 上面代码中，proxy.preventExtensions()方法返回true，但这时Object.isExtensible(target)会返回true,因此报错。

            // 为了防止出现这个问题，通常要在Proxy.preventExtensions()方法里面，调用一次Object.preventExtensions();
            console.log('--------------------------------');
            const target = {};
            const proxy = new Proxy(target, {
                preventExtensions(target) {
                    console.log('called');
                    Object.preventExtensions(target);
                    // return false; //  TypeError: 'preventExtensions' on proxy: trap returned falsish
                    return true;
                }
            })
            console.log(Object.preventExtensions(proxy)); // Proxy {}
            */


            /*
            // 13.setPrototypeOf()
            // setPrototypeOf()方法主要用来拦截Object.setPrototypeOf()方法
            var hander = {
                setPrototypeOf(target, proto) {
                    throw new Error('change the prototype is forbidden')
                }
            };
            var proto = {};
            var target = function() {};
            var p = new Proxy(target, hander);
            // Object.setPrototypeOf(p, proto); // Error: change the prototype is forbidden
            // 上面代码中，只要修改target的原型对象就会报错。
            // 注意，该方法只能返回布尔值，否则会被自带转为布尔值。另外，如果目标对象不可扩展(non-extensible)，setPrototypeOf()方法不得改变目标对象的原型.
            console.log('----------------------------- 1');
            var h = {
                setPrototypeOf(target, proto) {
                    console.log('called');
                //    return false;
                   return true;
                }
            };
            var t = function() {};
            var p2 = new Proxy(t, h);
            console.log(' Object.setPrototypeOf(p2, proto): ',  Reflect.setPrototypeOf(p2, proto)); // false true
            console.log(p2.__proto__ === proto); // false
            // console.log(Reflect.getPrototypeOf(p2)); // ƒ () { [native code] }

            console.log('------------------------------------ 2');
            let o = {a: 1};
            let prot = {b: 2};
            Object.preventExtensions(o);
            let proxy = new Proxy(o, {
                setPrototypeOf(target, proto) {
                    console.log('target: ', target);
                    console.log('called 2');
                    // target = Object.create(proto);
                    // return ''; // TypeError: 'setPrototypeOf' on proxy: trap returned falsish
                    return true;
                }
            })
            // console.log('Reflect.setPrototypeOf(proxy, prot): ', Reflect.setPrototypeOf(proxy, prot)); // false
            console.log('Reflect.setPrototypeOf(proxy, prot): ', Reflect.setPrototypeOf(proxy, prot)); // TypeError: 'setPrototypeOf' on proxy: trap returned truish for setting a new prototype on the non-extensible proxy target
            */


            /*
            // 3.Proxy.revocable()  revoked:撤销的
            // Proxy.revocable()返回一个可取消的Proxy实例。
            let target = {}, hander = {};
            let { proxy, revoke } = Proxy.revocable(target, hander);
            // console.log('o: ', proxy);
            // console.log('o: ', revoke);
            proxy.foo = 123;
            console.log(target); // {foo: 123}
            console.log(proxy.foo); // 123 
            revoke();
            console.log(target); // {foo: 123}
            // console.log(proxy.foo); // TypeError: Cannot perform 'get' on a proxy that has been revoked:无法对已吊销的代理执行“get”
            // Proxy.revocable()方法返回一个对象，该对象的proxy属性是Porxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出错误。

            // Proxy.revocable()的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。
            */


            /**/
            // 4.this问题
            // 虽然Proxy可以代理针对目标对象的访问，但它不是目标对象的透明代理，*即不做任何拦截情况下*，也无法保证与目标对象的行为一致。主要原因就是Proxy代理的情况下，目标对象内部的this关键字会指向Proxy代理。
            var target = {
                a: 'aa',
                m() {
                    console.log(this);
                    console.log(this === target);
                    console.log(this === p);
                }
            };
            var p = new Proxy(target, {
                // set(target, key, value, ) {
                // }
            });
            target.m();
            p.m()
            // 上面代码中，一旦proxy代理target.m,后者内部的this就指向proxy而不是target.

            console.log('------------------');

            // 接下来，由于this指向的变化，导致Proxy无法代理目标对象。
            const _name = new WeakMap();
            class Person {
                constructor(n) {
                    console.log(this, '----this');
                    // this.name = n;
                    _name.set(this, n)
                }
                say() {
                    console.log(this,'say this');
                    // console.log(this.name);
                }
                get name() {
                    console.log(this, 'get this');
                    return _name.get(this)
                }
            }
            const join = new Person('join');
            join.age = 12;
            console.log(join.name);
            join.say();
            console.log('------------------ 2');
            const pr = new Proxy(join, {
                // get(target, key) {
                //     return target[key]
                // }
            });
            console.log(pr, '======= pr');
            console.log(pr.name); // undefined
            pr.say();
            // 上面代码中，目标对象join的name属性，实际保存在外部WeakMap对象_name上面，通过this键区分。由于通过pr.name访问时，this指向proxy，导致无法取到值，所以返回undefined。
            console.log('------------------ 3');
            
            // 此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以Proxy无法代理这些原生对象的属性。
            let t = new Date();
            let p1 = new Proxy(t, {
                get(target, key) {
                    // return target[key].bind(this) // error
                    return target[key].bind(target) // ok
                    return Reflect.get(target, key)
                }
            });
            // console.log(p1.toString()); // Method Date.prototype.toString called on incompatible receiver [object Object] 方法日期.prototype.toString在不兼容的接收器[对象对象]上调用
            // console.log(p1.getDate); // ƒ getDate() {[native code]}
            console.log(p1.getDay()); // TypeError: this is not a Date object.

            // 上面代码中，getDate()方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。如果this绑定原生始对象，就可以解决这个问题：

        </script>
    </body>
</html>
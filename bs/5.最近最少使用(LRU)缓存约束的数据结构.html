<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>



<body>
  <script>
    // https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&mid=2649132814&idx=1&sn=c74ff32da6f32c2f42fe5ac6ec1d1ca6&chksm=be58a8a3892f21b598a3b40f2121900f4663d368e8092c761e4730466e362a526315f45a9dfd&scene=27
    // 设计一个遵循最近最少使用 (LRU) 缓存约束的数据结构。
    // 实现 LRUCache 类：
    // LRUCache(int capacity) 用正容量初始化 LRU 缓存。
    // int get(int key) 如果key存在则返回key的值，否则返回-1。
    // void put(int key, int value) 如果键存在，则更新键的值。否则，将键值对添加到缓存中。如果键的数量超过此操作的容量，则驱逐最近最少使用的键。


    class LRUCache {
      constructor(capacity) {
        this.cache = new Map;
        this.capacity = capacity
      }
      get(key) {
        if (this.cache.has(key)) {
          const value = this.cache.get(key)
          this.cache.delete(key)
          this.cache.set(key, value)
          return value
        }
        return -1
      }
      put(key, value) {
        if (this.cache.has(key)) {
          this.cache.delete(key)
        } else {
          if (this.cache.size >= this.capacity) {
            console.log(this.cache.keys().next().value, 'this.cache.keys().next().value');
            this.cache.delete(this.cache.keys().next().value)
          }
        }
        this.cache.set(key, value)
      }
    }

    const lRUCache = new LRUCache(2)
    lRUCache.put(1, 11) // The cache is {1=1}
    lRUCache.put(2, 22)
    console.log(lRUCache.cache);
    console.log(lRUCache.get(1));
    lRUCache.put(3, 33)
    console.log(lRUCache.get(2)); // -1
    lRUCache.put(4, 44)
    console.log(lRUCache.get(1)); // -1
    console.log(lRUCache.get(3))    // Return 33
    console.log(lRUCache.get(4))    // Return 44






  </script>

</body>

</html>
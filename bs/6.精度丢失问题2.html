<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- <script type="text/javascript" src="https://static.runoob.com/assets/js/mathml/mspace.js"></script> -->
</head>

<body>
  <div>
    <!-- http://www.vue5.com/mathml/mathml_multiplication.html -->
    <!-- http://www.vue5.com/mathml/mathml.html -->
    <!-- https://iowiki.com/mathml/mathml_style.html -->
    <math xmlns="http://www.w3.org/1998/Math/MathML">
      <mstack>
        <msgroup>
          <mn>123</mn>
          <msrow>
            <mo>×</mo>
            <mn>321</mn>
          </msrow>
        </msgroup>
        <msline />
        <msgroup shift="1">
          <mn>123</mn>
          <mn>246</mn>
          <mn>369</mn>
        </msgroup>
        <msline />
        <mn>39483</mn>
        &vellip;
      </mstack>
    </math>
  </div>
  <hr>
  <div>
    <span class="MJX_Assistive_MathML" role="">
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>X</mi>
        <mo>=</mo>
        <mi>a</mi>
        <mo>∗</mo>
        <msup>
          <mn>2</mn>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>e</mi>
          </mrow>
        </msup>
      </math></span>
  </div>
  <script>

    // https://zhuanlan.zhihu.com/p/100353781

    // 精度丢失的原因
    // 总结：计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}
    // 存储二进制的科学记数法,因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，
    // 当再转换为十进制时就造成了计算误差


    // 1.tofixed()对于小数最后一位为5时进位不正确的问题
    //firefox/chrome中toFixed 兼容性问题
    1.35.toFixed(1) // 1.4 正确
    1.336.toFixed(2) // 1.33  错误
    1.3335.toFixed(3) // 1.333 错误
    1.33335.toFixed(4) // 1.3334 正确
    1.333335.toFixed(5)  // 1.33333 错误
    1.3333335.toFixed(6) // 1.333333 错误

    // 可以看到，小数点位数为2，5时四舍五入是正确的，其它是错误。
    // 如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。
    // 原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去
    1.005.toPrecision(21) // 1.00499999999999989342

    // 修复方式1

    /**
     * 修复firefox/chrome中toFixed兼容性问题
     * firefox/chrome中，对于小数最后一位为5时进位不正确，
     * 修复方式即判断最后一位为5的，改成6，再调用toFixed
     * 
     * @params number number 原始数据
     * @params precision number 精度
     */
    function toFixed(number, precision) {
      var str = number + ''
      var last = str.slice(-1)
      if (last === '5') {
        last = '6'
        str = str.slice(0, -1) + last
      }
      return (+str).toFixed(precision)
    }
    var r = toFixed(1.335, 2)
    // console.log('r: ', r);
    // console.log(toFixed(1.3335, 3)); // 1.334 ok
    // console.log(1.3335.toFixed(3)); // 1.333 error

    // 修复方式2: 先扩大再缩小法 (有bug)
    function toFixed2(num, s) {
      var times = 10 ** s;
      console.log('times: ', times);
      // +0.5是为了舍入
      var des = num * times + 0.5
      console.log('des: ', des);
      var r = parseInt(des, 10) / times
      return r + ''
    }
    // console.log(toFixed(1.005, 2)); // 1.01 // ok
    // console.log(toFixed2(1.005, 2)); // 1 // error
    // console.log(toFixed2(1.3335, 3)); // 1.334 // ok
    // console.log(1.005.toFixed(2)); // 1.00 error


    /**
      * floatObj 包含加减乘除四个方法，能确保浮点数运算不丢失精度
      *
      * 精度丢失问题（或称舍入误差，其根本原因是二进制和实现位数限制有些数无法有限表示
      * 以下是十进制小数对应的二进制表示
      *      0.1 >> 0.0001 1001 1001 1001…（1001无限循环）
      *      0.2 >> 0.0011 0011 0011 0011…（0011无限循环）
      * 计算机里每种数据类型的存储是一个有限宽度，比如 JavaScript
        使用 64 位存储数字类型，因此超出的会舍去。舍去的部分就是精度丢失的部分。
      *
      * ** method **
      *  add / subtract / multiply /divide
      *
      * ** explame **
      *  0.1 + 0.2 == 0.30000000000000004 （多了 0.00000000000004）
      *  0.2 + 0.4 == 0.6000000000000001  （多了 0.0000000000001）
      *  19.9 * 100 == 1989.9999999999998 （少了 0.0000000000002）
      *
      * floatObj.add(0.1, 0.2) === 0.3
      * floatObj.multiply(19.9, 100) === 1990
      *
      */

    var floatObj = (function () {
      function isInteger(n) {
        return Number.isInteger(n)
      }

      /**
       * 将一个浮点数转成整数，返回整数和倍数。如 3.14 >> 314，倍数是 100
       * @param floatNum {number} 小数
       * @return {object} {times:100, num: 314}
       */
      function toInteger(floatNum) {
        var ret = { times: 0, num: 0 }

        if (isInteger(floatNum)) {
          ret.num = floatNum
          return ret
        }

        var isNeative = floatNum < 0
        var strNum = floatNum + ''
        var dotPos = strNum.indexOf('.')
        var len = strNum.substr(dotPos + 1).length
        var times = Math.pow(10, len) // 精度倍数
        /* 为什么加0.5?
            前面讲过乘法也会出现精度问题
            假设传入0.16344556此时倍数为100000000
            Math.abs(0.16344556) * 100000000=0.16344556*10000000=1634455.5999999999 
            少了0.0000000001
            加上0.5 0.16344556*10000000+0.5=1634456.0999999999 parseInt之后乘法的精度问题得以矫正
        */
        var intNum = parseInt((Math.abs(floatNum) * times) + 0, 10)
        ret.times = times
        if (isNeative) {
          intNum = -intNum
        }
        ret.num = intNum
        return ret
      }
      // console.log(' ', toInteger(1.005));
      console.log(' toInteger(-19.923): ', toInteger(19.923));
      console.log(' toInteger(-19.923): ', toInteger(19.3));
      // console.log(' toInteger(-19.923): ', toInteger(-19.0));
      /*
       * 核心方法，实现加减乘除运算，确保不丢失精度
       * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）
       * @param a {number} 运算数1
       * @param b {number} 运算数2
       */
      function operation(a, b, op) {
        var o1 = toInteger(a)
        var o2 = toInteger(b)
        var n1 = o1.num
        var n2 = o2.num
        var t1 = o1.times
        var t2 = o2.times
        var max = t1 > t2 ? t1 : t2
        var res = null
        switch (op) {
          case 'add':
            if (t1 === t2) { // 两个小数相同
              res = n1 + n2
            } else if (t1 > t2) {
              res = n1 + n2 * (t1 - t2)
            } else {
              res = n1 * (t2 - t1) + n2
            }
            return res / max
          case 'subtract':
            if (t1 === t2) {
              res = n1 - n2
            } else if (t1 > t2) {
              res = n1 - n2 * (t1 - t2)
            } else {
              res = n1 * (t2 - t1) - n2
            }
            return res / max
          case 'multiply':
            // 325*3153/(100*1000) 扩大100倍 ==>缩小100倍
            res = (n1 * n2) / (t1 * t2)
            return res
          case 'divide':
            // (325/3153)*(1000/100)  缩小100倍 ==>扩大100倍
            res = t1 > 0 ? (n1 / n2) * (t2 / t1) : n1 / n2
            return res
        }
      }
      function add(a, b) {
        return operation(a, b, 'add')
      }
      function subtract(a, b) {
        return operation(a, b, 'subtract')
      }
      function multiply(a, b) {
        return operation(a, b, 'multiply')
      }
      function divide(a, b) {
        return operation(a, b, 'divide')
      }

      return {
        add, subtract, multiply, divide
      }

    })()
    // console.log('floatObj.multiply(3.25,3.153): ', floatObj.multiply(3.25, 3.153));
    // console.log('floatObj.divide(3.25,3.153): ', floatObj.divide(3.25, 3.153));
    // console.log('floatObj.divide(3.25,3.153): ', floatObj.divide(1, 3));
    // console.log('floatObj.divide(3.25,3.153): ', floatObj.divide(2, 1.2));



  </script>
</body>

</html>